'''Created on May 23, 2019@author: ashto'''from _collections import defaultdictimport Tokenizerimport mathimport dill as pickle # use dill to load lambdas and defaultdicts -- pickle does not support those 2 typesclass InvertedIndex:        def __init__(self):        self.Tokenizer = Tokenizer.Tokenizer()        self.invertedIndex = defaultdict(lambda: defaultdict(lambda: [0,0,0]))        self.totalFileCount = (74 * 500) - 3        self.postingsGreaterThan2 = []        self.pickleName = "invertedIndex.pickle"        def createInvertedIndex(self, numFolders, numFiles):        for folderNum in range(numFolders):            for fileNum in range(numFiles):                tokens = self.Tokenizer.generateTokenDict(folderNum, fileNum) #terms and their freqs                for token in tokens:                    filePath = self.Tokenizer.generateFilePath(folderNum, fileNum)                    tfScore = 1 + math.log(tokens[token], 10)                    self.invertedIndex[token][filePath][0] = tfScore                                print(f"Added folder: {folderNum}")#                 print(f" \t Added doc: {folderNum}/{fileNum}")                                    self.addIDFandTFIDF(self.invertedIndex)        self.dumpIntoPickle(self.invertedIndex)                def addIDFandTFIDF(self, invertedIndex):        for token in invertedIndex:            postingsLen = len(invertedIndex[token])            IDF = self.totalFileCount / postingsLen            if postingsLen > 2:                self.postingsGreaterThan2.append(invertedIndex[token])            for posting in invertedIndex[token]: #for posting in postings (filePaths)                TF = invertedIndex[token][posting][0]                invertedIndex[token][posting][1] = IDF                invertedIndex[token][posting][2] = TF * IDF        def dumpIntoPickle(self, invertedIndex):        preparedIndex = dict(invertedIndex) # defaultdicts are difficult to pickle https://www.datacamp.com/community/tutorials/pickle-python-tutorial#whatfor        try:            outPickle = open(self.pickleName, "wb")            pickle.dump(preparedIndex, outPickle)                    finally:            outPickle.close()        def loadPickle(self, pickleToLoad):        try:            inPickle = open(pickleToLoad, "rb")            preparedInvertedIndex = pickle.load(inPickle)            invertedIndex = defaultdict(lambda: defaultdict(lambda: [0, 0 ,0]), preparedInvertedIndex) # Converting back from dict to defaultdict            return invertedIndex                finally:            inPickle.close()                    def printInvertedIndex(self, invertedIndex):        for key, val in invertedIndex.items():            print(f"KEY: {key}, VALUE: {val}")            for key2, val2 in val.items():                print(f"\t KEY2: {key2}, VALUE2: {val2}")                if __name__ == "__main__":    II = InvertedIndex()    II.createInvertedIndex(75, 500)    II.loadPickle(II.pickleName)                  